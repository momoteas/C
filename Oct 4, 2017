1 类型定义：
    。自定义数据类型：
        。C语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字。比如：typedef int length，使得length成为int的别名；
        。例如：    typedef struct{
                      int month;
                      int day;
                      int year
                   }date;
2 联合：
    。关键字 union，例如： union AnElt{
                            int i;
                            char c;
                        }elt1, elt2;
    。存储：
        。所有的成员共享一个空间；
        。同一时间只有一个成员是有效的；
        。union大大小是其最大的成员；
    。初始化：
        。对第一成员做初始化；
3 全局变量：
    。全局变量具有全局的生存期和作用域；与任何函数无关；在任何函数内部都可以使用它们；
    。没有做初始化的全局变量会得到0值，指针会得到NULL值；只能在编译时刻已知的值来初始化全局变量；它的初始化发生在main函数之前；
    。如果函数内部存在与全局变量同名的变量，则全局变量被隐藏（覆盖）；
4 静态本地变量：
    。关键字 static
    。当函数离开的时候，静态本地变量会继续存在并保持其值；
    。静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值；
    。静态本地变量实际上是特殊的全局变量；它们位于相同的内存区域；静态本地变量具有全局的生存期，函数内的局部作用域；static在这里的意思是局部作用域；
5 全局变量贴士：
    。返回指针的函数：
        。返回本地变量的地址是危险的；返回全局变量或静态本地变量的地址是安全的；
        。返回在函数内malloc的内存是安全的，但是容易造成问题；
        。最好的做法是返回传入的指针；
    。不要使用全局变量来在函数间传递参数和结果；
6 宏：
    。编译预处理指令：
        。#开头的是编译预处理指令；
        。它们不是C语言的成分，但是C语言程序离不开它们；
        。#define用来定义一个宏；
    。#define:
        。#define<名字> <值>
        。注意没有结尾的分号，因为不是C语句
        。名字必须是一个单词，值可以是各种东西；
        。在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值，完全的文本替换；
        。gcc --save-temps;
        。没有值的宏：
            。#define _DEBUG
            。这类宏用于条件编译，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了；
        。预定义的宏：__LINE__, __FILE__, __DATE__, __TIME__, __STDC__;    
    。带参数的宏：
        。#define cube(x)((x)*(x)*(x))
        。宏可以带参数
        。带参数的宏的原则：
            。一切都要括号；
            。整个值要括号；
            。参数出现的每个地方都要括号；
        。运算符：#和##，可以自行学习；
        。缺点：宏没有类型检查
        。部分宏会被inline函数取代；
7 大程序：
    。多个.c文件：一个源代码文件太长了适合分成几个文件；
    。项目：
        。在Dev C++中新建一个项目，然后把几个源代码文件加入进去；
        。对于项目，Dev C++的编译会把一个项目中所有的源代码文件都编译后，链接起来；
        。有的IDE有分开的编译和构建两个按钮，前者是对单个源代码文件的编译，后者是对整个项目做链接；
8 头文件：
    。把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器在编译的时候就知道函数的原型；
    。#include是一个编译预处理指令，和宏一样，在编译之前就处理了。它把那个文件的全部文本内容原封不动地插入到它所在额地方；
    。include的两种形式插入头文件：“”还是<>:
        。“”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找；
        。<>让编译器只在指定的目录去找。编译器自己知道自己的标准库的头文件在那里；
        。环境变量和编译器命令行参数也可以指定寻找头文件的目录；
        。一般，系统给的用<>，自己定义的用"";
    。#include的误区：
        。#include不是用来引入库的；
        。stdio.h里只有printf的原型，pintf的代码在另外的地方，某个.lib(windows)或.a(Unix)中；
        。现在的C语言编译器默认会引入所有的标准库；
        。#include<stdio.h>只是为了让编译器知道printf函数额原型，保证你调用时给出的参数值是正确的类型；
    。头文件：
        。一般的做法是任何.c都有对应的同名.h，把所有对外公开的函数的原型和全局变量的声明都放进去；
    。不对外公开的函数：
        。在函数前面加上static就使得它成为只能在所在的编译单元中被使用的函数；
        。在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量；
9 声明：
    。全局变量的声明：关键字extern，一般在.h中声明；
    。声明和定义：
        。声明是不产生代码的东西：函数原型，变量声明，结构声明，宏声明，枚举声明，类型声明，inline函数；
        。定义是产生代码额东西；
    。头文件：
        。只有声明可以被放在头文件中，是规则不是法律；
        。否则会造成一个项目中多个编译单元里有重名的实体；
    。标准头文件结构：
        。          #ifndef _MAX_H_
                    #define _MAX_H_
                    :
                    :
                    :
                    #endif
10 格式化输入和输出：
    。格式化的输入和输出：
        。printf: %[flags][width][.prec][hlL]type （hlL：修饰符）
        。scanf: %[flags]type;
    。printf和scanf的返回值：
        。scanf:读入的项目数，printf:输出的字符数;
11 文件输入输出：
    。用>和<来重定向；
    。FILE：
        。FILE* fopen(const char* restrict path, const char* restrict mode);
        。int fclose(FILE *stream);
        。fscanf(FILE*, ...)
        。fprintf(FILE*, ...)
        。打开文件的标准代码：
            。FILE* fp=fopen("file", "r");
              if (fp){
                fscanf(fp, ...);
                fclose(fp);
              }esle{
                ...
              }
            。如果没有打开，返回NULL；
            。fopen参数：
                。r 打开只读；r+ 打开读写；从头开始；w 打开写。如果不存在就新建，如果存在则清空；w+ 打开读写。如果不存在则新建，如果存在清空；
                。a 打开追加。如果不存在则新建，如果存在则从文件尾开始；[w]x 只新建，如果文件已存在则不能打开；
12 二进制文件：
    


























